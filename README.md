{
  "readme": "# checker_bw: Cross-Chain Bridge Event Listener Simulator\n\nThis repository contains a Python-based simulation of a critical component in a cross-chain bridge architecture: the event listener, also known as a relayer or oracle. This script connects to a source blockchain (like Ethereum or a compatible testnet), listens for specific events from a bridge contract, validates them, and simulates the process of relaying this information to a destination chain.\n\nThis project is designed as an architectural showcase, demonstrating the principles of modularity, state management, and resilience required for real-world blockchain infrastructure components.\n\n## Concept\n\nA cross-chain bridge enables the transfer of assets or data from one blockchain to another. A common design pattern is the \"lock-and-mint\" mechanism:\n\n1.  **Lock:** A user deposits assets into a smart contract on the source chain (e.g., locking 100 ETH).\n2.  **Event Emission:** The source chain contract emits an event (`AssetLocked`) containing details of the deposit (user, amount, destination chain).\n3.  **Validation & Relay:** A network of off-chain listeners (validators/relayers) detects this event. They wait for a certain number of block confirmations to ensure the transaction is final and not part of a blockchain reorganization (reorg).\n4.  **Mint:** After validating the event, the relayers submit a signed message to a contract on the destination chain. Once a sufficient number of signatures are collected, the destination contract mints a corresponding amount of a wrapped asset (e.g., 100 wETH) for the user.\n\nThis script simulates the crucial **Step 3**, acting as one of these off-chain listeners.\n\n## Code Architecture\n\nThe script is designed with a clear separation of concerns, implemented through several distinct classes:\n\n-   `CrossChainEventListener`: The main orchestrator. It manages the connection to the source chain's RPC node, handles the main polling loop, and determines which blocks to scan.\n\n-   `StateDB`: A simple, file-based persistence layer. It keeps track of the `last_processed_block` and a list of `processed_event_ids`. This ensures that the listener can be stopped and restarted without losing its place or re-processing the same event (preventing replay attacks).\n\n-   `EventParser`: A static utility class responsible for decoding raw log data received from the blockchain into a structured, human-readable format. This isolates the complex and often error-prone parsing logic.\n\n-   `TransactionProcessor`: This class takes a parsed event and applies the core business logic. It checks if the event has already been processed using the `StateDB` and then coordinates with the `SignatureRelaySimulator` to forward the event.\n\n-   `SignatureRelaySimulator`: Simulates the final step of a relayer's duty. It generates a cryptographic signature for the event data (as a real validator would) and sends the event payload and signature to a mock API endpoint, simulating a submission to the destination chain's relayer network.\n\n### Data Flow Diagram\n\n```\n[Source Chain RPC] <---(getLogs)-- [CrossChainEventListener]\n          |\n          v (Raw Log Data)\n     [EventParser]\n          |\n          v (Parsed Event Data)\n [TransactionProcessor] ----(check)----> [StateDB]\n          |\n          v (Validated Event)\n [SignatureRelaySimulator]\n          |\n          v (POST Request with Signed Payload)\n[Destination Chain API Endpoint (Mock)]\n```\n\n## How it Works\n\n1.  **Initialization**: The `CrossChainEventListener` connects to the specified RPC endpoint and initializes all helper classes, including loading the previous state from `listener_state.json` via `StateDB`.\n2.  **Polling Loop**: The listener enters an infinite loop, periodically waking up to check for new blocks.\n3.  **Block Scanning**: It determines the range of blocks to scan, from the `last_processed_block + 1` up to the `latest_block_number - BLOCK_CONFIRMATIONS`.\n4.  **Log Fetching**: It queries the RPC node for all event logs within that block range that match the specified bridge contract address and event topic hash.\n5.  **Parsing**: For each log found, the `EventParser` decodes the data into a structured dictionary (e.g., user address, amount).\n6.  **Processing**: The `TransactionProcessor` receives the parsed event. It first queries the `StateDB` to ensure the event's unique ID (`tx_hash-log_index`) hasn't been processed before.\n7.  **Signing & Relaying**: If the event is new, the `SignatureRelaySimulator` signs a digest of the event data and `POST`s it to a mock API endpoint.\n8.  **State Update**: If the relay is successful, the `TransactionProcessor` instructs the `StateDB` to mark the event ID as processed. Finally, the `CrossChainEventListener` updates the `last_processed_block` in the `StateDB` and saves the state to the JSON file.\n9.  **Wait**: The listener then sleeps for `POLL_INTERVAL_SECONDS` before starting the cycle again.\n\n## Usage\n\n### 1. Prerequisites\n- Python 3.8+\n- An RPC URL for an Ethereum-compatible network. You can get one for free from services like [Infura](https://infura.io/) or [Alchemy](https://www.alchemy.com/).\n\n### 2. Setup\n\nFirst, clone the repository and navigate into the directory:\n```bash\ngit clone https://github.com/your-username/checker_bw.git\ncd checker_bw\n```\n\nNext, create a virtual environment and install the required dependencies:\n```bash\npython -m venv venv\nsource venv/bin/activate  # On Windows, use `venv\\Scripts\\activate`\npip install -r requirements.txt\n```\n\n### 3. Configuration\n\nThe script is configured via environment variables. For ease of use, create a `.env` file in the project's root directory. The script will automatically load variables from this file.\n\n**Example `.env` file:**\n```dotenv\n# Required: Your RPC URL for the source chain (e.g., Sepolia)\nRPC_URL=\"https://sepolia.infura.io/v3/your-infura-project-id\"\n\n# Optional: Override the default bridge contract address.\n# BRIDGE_CONTRACT_ADDRESS=\"0x...\"\n```\n\nThe script is pre-configured by default to listen for `Deposit` events on the Sepolia WETH contract (`0x7b79995e5f793A07Bc00c21412e50Eaae098E7f9`), which serves as a great real-world example of a high-traffic contract emitting events.\n\n### 4. Running the Script\n\nWith your virtual environment activated and the `.env` file configured, start the listener by running the main Python script:\n```bash\npython script.py\n```\n\nYou will see log output in your terminal as the listener connects, scans for blocks, and processes any events it finds.\n\n**Expected Output:**\n\n```\n2023-10-27 15:30:00 - INFO - Successfully connected to Ethereum node. Chain ID: 11155111\n2023-10-27 15:30:00 - INFO - SignatureRelaySimulator initialized for validator: 0x...\n2023-10-27 15:30:00 - INFO - Starting Cross-Chain Event Listener...\n2023-10-27 15:30:02 - INFO - Scanning for events from block 4850101 to 4850120\n2023-10-27 15:30:05 - INFO - Found 2 potential event(s). Parsing and processing...\n2023-10-27 15:30:05 - INFO - Processing new event: 0x...-34 from block 4850115\n2023-10-27 15:30:05 - INFO - Relaying event 0x...-34 to https://httpbin.org/post\n2023-10-27 15:30:06 - INFO - Successfully relayed event. Response: { ... }\n2023-10-27 15:30:06 - INFO - Successfully processed and marked event 0x...-34 as complete.\n...\n2023-10-27 15:30:07 - INFO - Finished scan. Last processed block updated to: 4850120\n2023-10-27 15:30:07 - INFO - Waiting for 15 seconds before next poll.\n```\n\nA `listener_state.json` file will be created in the same directory to store the script's progress."
}